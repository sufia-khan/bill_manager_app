import 'package:hive_flutter/hive_flutter.dart';
import '../models/bill.dart';

/// Local Database Service using Hive
///
/// This is the PRIMARY data source (offline-first architecture).
/// All operations happen here first, then sync in background.
///
/// Key features:
/// - Fast local CRUD operations
/// - Bills are immediately available
/// - Works completely offline
class LocalDbService {
  static const String _billsBoxName = 'bills';
  static const String _settingsBoxName = 'settings';

  Box<Bill>? _billsBox;
  Box<dynamic>? _settingsBox;

  /// Initialize Hive and open boxes
  Future<void> initialize() async {
    await Hive.initFlutter();

    // Register Bill adapter (generated by build_runner)
    if (!Hive.isAdapterRegistered(0)) {
      Hive.registerAdapter(BillAdapter());
    }

    // Open boxes
    _billsBox = await Hive.openBox<Bill>(_billsBoxName);
    _settingsBox = await Hive.openBox<dynamic>(_settingsBoxName);
  }

  /// Get bills box (throw if not initialized)
  Box<Bill> get billsBox {
    if (_billsBox == null) {
      throw StateError(
        'LocalDbService not initialized. Call initialize() first.',
      );
    }
    return _billsBox!;
  }

  /// Get settings box
  Box<dynamic> get settingsBox {
    if (_settingsBox == null) {
      throw StateError(
        'LocalDbService not initialized. Call initialize() first.',
      );
    }
    return _settingsBox!;
  }

  // ==================== BILL OPERATIONS ====================

  /// Get all bills
  List<Bill> getAllBills() {
    return billsBox.values.toList();
  }

  /// Get a bill by ID
  Bill? getBill(String id) {
    return billsBox.get(id);
  }

  /// Get bills sorted by due date
  List<Bill> getBillsSortedByDueDate() {
    final bills = getAllBills();
    bills.sort((a, b) => a.dueDate.compareTo(b.dueDate));
    return bills;
  }

  /// Get unpaid bills
  List<Bill> getUnpaidBills() {
    return billsBox.values.where((bill) => !bill.paid).toList();
  }

  /// Get overdue bills
  List<Bill> getOverdueBills() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    return billsBox.values.where((bill) {
      if (bill.paid) return false;
      final dueDate = DateTime(
        bill.dueDate.year,
        bill.dueDate.month,
        bill.dueDate.day,
      );
      return dueDate.isBefore(today);
    }).toList();
  }

  /// Get bills pending sync
  List<Bill> getPendingSyncBills() {
    return billsBox.values.where((bill) => bill.isSyncPending).toList();
  }

  /// Add a new bill
  /// Saves locally immediately, marks as pending sync
  Future<Bill> addBill(Bill bill) async {
    bill.syncStatus = 'pending';
    bill.updatedAt = DateTime.now();
    await billsBox.put(bill.id, bill);
    return bill;
  }

  /// Update an existing bill
  Future<Bill> updateBill(Bill bill) async {
    bill.markPendingSync();
    await billsBox.put(bill.id, bill);
    return bill;
  }

  /// Delete a bill
  Future<void> deleteBill(String id) async {
    await billsBox.delete(id);
  }

  /// Mark a bill as paid
  /// For monthly bills, creates the next month's entry
  Future<Bill?> markBillPaid(String id, {String? newBillId}) async {
    final bill = getBill(id);
    if (bill == null) return null;

    bill.paid = true;
    bill.markPendingSync();
    await billsBox.put(id, bill);

    // For monthly bills, create next month's entry
    if (bill.isMonthly && newBillId != null) {
      final nextBill = bill.createNextMonthBill(newBillId);
      await addBill(nextBill);
      return nextBill;
    }

    return null;
  }

  /// Mark a bill as synced
  Future<void> markBillSynced(String id) async {
    final bill = getBill(id);
    if (bill != null) {
      bill.markSynced();
      await billsBox.put(id, bill);
    }
  }

  /// Bulk upsert bills (used during sync)
  Future<void> upsertBills(List<Bill> bills) async {
    for (final bill in bills) {
      await billsBox.put(bill.id, bill);
    }
  }

  /// Clear all bills (use with caution)
  Future<void> clearAllBills() async {
    await billsBox.clear();
  }

  // ==================== SETTINGS OPERATIONS ====================

  /// Check if user has been through onboarding
  bool get hasCompletedOnboarding {
    return settingsBox.get('hasCompletedOnboarding', defaultValue: false);
  }

  /// Mark onboarding as completed
  Future<void> setOnboardingComplete() async {
    await settingsBox.put('hasCompletedOnboarding', true);
  }

  /// Get the last sync timestamp
  DateTime? get lastSyncTime {
    final timestamp = settingsBox.get('lastSyncTime');
    if (timestamp == null) return null;
    return DateTime.parse(timestamp);
  }

  /// Set the last sync timestamp
  Future<void> setLastSyncTime(DateTime time) async {
    await settingsBox.put('lastSyncTime', time.toIso8601String());
  }

  /// Check if user is in guest mode
  bool get isGuestMode {
    return settingsBox.get('isGuestMode', defaultValue: true);
  }

  /// Set guest mode
  Future<void> setGuestMode(bool value) async {
    await settingsBox.put('isGuestMode', value);
  }

  /// Close all boxes
  Future<void> close() async {
    await _billsBox?.close();
    await _settingsBox?.close();
  }
}
