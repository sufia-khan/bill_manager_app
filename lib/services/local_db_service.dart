import 'package:hive_flutter/hive_flutter.dart';
import '../models/bill.dart';

/// Local Database Service using Hive
///
/// This is the PRIMARY data source (offline-first architecture).
/// All operations happen here first, then sync in background.
///
/// ‚ö†Ô∏è CRITICAL: USER ACCOUNT ISOLATION ‚ö†Ô∏è
/// Each user (Google or Guest) has their own isolated Hive boxes.
/// This prevents data leakage between accounts on the same device.
///
/// Key features:
/// - Fast local CRUD operations
/// - Bills are immediately available
/// - Works completely offline
/// - User-scoped storage (bills_<userId>, settings_<userId>)
class LocalDbService {
  // Current active user ID (Firebase UID or guest UUID)
  String? _currentUserId;

  Box<Bill>? _billsBox;
  Box<dynamic>? _settingsBox;

  /// Get current user ID
  String? get currentUserId => _currentUserId;

  /// Generate user-scoped box name
  /// Example: bills_a1b2c3d4 or bills_guest_xyz123
  String _getUserBoxName(String baseBoxName, String userId) {
    return '${baseBoxName}_$userId';
  }

  /// Initialize Hive with user-scoped boxes
  /// MUST be called with a valid userId (Firebase UID or guest ID)
  Future<void> initialize(String userId) async {
    if (userId.isEmpty) {
      throw ArgumentError(
        'User ID cannot be empty. Data isolation requires a valid user ID.',
      );
    }

    await Hive.initFlutter();

    // Register Bill adapter (generated by build_runner)
    if (!Hive.isAdapterRegistered(0)) {
      Hive.registerAdapter(BillAdapter());
    }

    // Set current user and open their boxes
    await _openUserBoxes(userId);
  }

  /// Open boxes for a specific user
  Future<void> _openUserBoxes(String userId) async {
    _currentUserId = userId;

    final billsBoxName = _getUserBoxName('bills', userId);
    final settingsBoxName = _getUserBoxName('settings', userId);

    print('[LocalDbService] üì¶ === OPENING USER BOXES ===');
    print('[LocalDbService] User ID: $userId');
    print('[LocalDbService] Bills box name: $billsBoxName');
    print('[LocalDbService] Settings box name: $settingsBoxName');

    _billsBox = await Hive.openBox<Bill>(billsBoxName);
    _settingsBox = await Hive.openBox<dynamic>(settingsBoxName);

    print('[LocalDbService] ‚úÖ Boxes opened successfully');
    print('[LocalDbService] Bills count in this box: ${_billsBox!.length}');
    print('[LocalDbService] üì¶ === BOXES READY ===');
  }

  /// Close current user's boxes
  /// CRITICAL: Must be called before switching users to prevent data leakage
  Future<void> _closeCurrentBoxes() async {
    if (_billsBox != null && _billsBox!.isOpen) {
      await _billsBox!.close();
      print('[LocalDbService] Closed bills box for user: $_currentUserId');
    }
    if (_settingsBox != null && _settingsBox!.isOpen) {
      await _settingsBox!.close();
      print('[LocalDbService] Closed settings box for user: $_currentUserId');
    }

    _billsBox = null;
    _settingsBox = null;
  }

  /// Switch to a different user
  /// This is called during login/logout to ensure data isolation
  ///
  /// Example flow:
  /// 1. User A logs out: switchUser(guestId)
  /// 2. User B logs in: switchUser(userBFirebaseUid)
  Future<void> switchUser(String newUserId) async {
    if (newUserId.isEmpty) {
      throw ArgumentError('New user ID cannot be empty');
    }

    if (newUserId == _currentUserId) {
      print(
        '[LocalDbService] ‚è≠Ô∏è Already on user: $newUserId, no switch needed',
      );
      return;
    }

    print('[LocalDbService] üîÑ === USER SWITCH START ===');
    print('[LocalDbService] From: $_currentUserId');
    print('[LocalDbService] To: $newUserId');

    // Close current user's boxes
    await _closeCurrentBoxes();
    print('[LocalDbService] üîí Previous user boxes closed');

    // Open new user's boxes
    await _openUserBoxes(newUserId);
    print('[LocalDbService] üîÑ === USER SWITCH COMPLETE ===');
  }

  /// Get bills box (throw if not initialized)
  Box<Bill> get billsBox {
    if (_billsBox == null) {
      throw StateError(
        'LocalDbService not initialized. Call initialize() first.',
      );
    }
    return _billsBox!;
  }

  /// Get settings box
  Box<dynamic> get settingsBox {
    if (_settingsBox == null) {
      throw StateError(
        'LocalDbService not initialized. Call initialize() first.',
      );
    }
    return _settingsBox!;
  }

  // ==================== BILL OPERATIONS ====================

  /// Get all bills
  List<Bill> getAllBills() {
    final bills = billsBox.values.toList();
    print('[LocalDbService] üìã getAllBills called for user: $_currentUserId');
    print('[LocalDbService] Found ${bills.length} bills in box');
    if (bills.isNotEmpty && bills.length <= 5) {
      for (final bill in bills) {
        print('[LocalDbService]   - ${bill.name} (due: ${bill.dueDate})');
      }
    }
    return bills;
  }

  /// Get a bill by ID
  Bill? getBill(String id) {
    return billsBox.get(id);
  }

  /// Get bills sorted by due date
  List<Bill> getBillsSortedByDueDate() {
    final bills = getAllBills();
    bills.sort((a, b) => a.dueDate.compareTo(b.dueDate));
    return bills;
  }

  /// Get unpaid bills
  List<Bill> getUnpaidBills() {
    return billsBox.values.where((bill) => !bill.paid).toList();
  }

  /// Get overdue bills
  List<Bill> getOverdueBills() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    return billsBox.values.where((bill) {
      if (bill.paid) return false;
      final dueDate = DateTime(
        bill.dueDate.year,
        bill.dueDate.month,
        bill.dueDate.day,
      );
      return dueDate.isBefore(today);
    }).toList();
  }

  /// Get bills pending sync (dirty bills)
  List<Bill> getPendingSyncBills() {
    return billsBox.values.where((bill) => bill.isDirty).toList();
  }

  /// Get all dirty bills (need cloud sync)
  List<Bill> getDirtyBills() {
    return billsBox.values.where((bill) => bill.isDirty).toList();
  }

  /// Add a new bill
  /// Saves locally immediately, marks as created (dirty)
  Future<Bill> addBill(Bill bill) async {
    bill.markAsCreated(); // Use new dirty flag method
    await billsBox.put(bill.id, bill);
    return bill;
  }

  /// Update an existing bill
  Future<Bill> updateBill(Bill bill) async {
    bill.markAsUpdated(); // Use new dirty flag method
    await billsBox.put(bill.id, bill);
    return bill;
  }

  /// Delete a bill
  Future<void> deleteBill(String id) async {
    await billsBox.delete(id);
  }

  /// Mark a bill as paid
  /// For monthly bills, creates the next month's entry
  Future<Bill?> markBillPaid(String id, {String? newBillId}) async {
    final bill = getBill(id);
    if (bill == null) return null;

    bill.paid = true;
    bill.markPendingSync();
    await billsBox.put(id, bill);

    // For monthly bills, create next month's entry
    if (bill.isMonthly && newBillId != null) {
      final nextBill = bill.createNextMonthBill(newBillId);
      await addBill(nextBill);
      return nextBill;
    }

    return null;
  }

  /// Mark a bill as synced
  Future<void> markBillSynced(String id) async {
    final bill = getBill(id);
    if (bill != null) {
      bill.markAsClean(); // Use new dirty flag method
      await billsBox.put(id, bill);
    }
  }

  /// Bulk upsert bills (used during sync)
  Future<void> upsertBills(List<Bill> bills) async {
    for (final bill in bills) {
      await billsBox.put(bill.id, bill);
    }
  }

  /// Clear all bills (use with caution)
  Future<void> clearAllBills() async {
    await billsBox.clear();
  }

  // ==================== SETTINGS OPERATIONS ====================

  /// Check if user has been through onboarding
  bool get hasCompletedOnboarding {
    return settingsBox.get('hasCompletedOnboarding', defaultValue: false);
  }

  /// Mark onboarding as completed
  Future<void> setOnboardingComplete() async {
    await settingsBox.put('hasCompletedOnboarding', true);
  }

  /// Get the last sync timestamp
  DateTime? get lastSyncTime {
    final timestamp = settingsBox.get('lastSyncTime');
    if (timestamp == null) return null;
    return DateTime.parse(timestamp);
  }

  /// Set the last sync timestamp
  Future<void> setLastSyncTime(DateTime time) async {
    await settingsBox.put('lastSyncTime', time.toIso8601String());
  }

  /// Close all boxes
  Future<void> close() async {
    await _billsBox?.close();
    await _settingsBox?.close();
  }
}
